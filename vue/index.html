<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    
</head>
<body>
    <div id="example">
        <h1>{{title}}</h1>
        <button v-on:click="title = '修改成功'">Change it</button>
    </div>
</body>
<script src="./vue.js"></script>
<script>
    var obj = {
        title:'test',
    }
    // Object.freeze(obj) //组织
    var vm = new Vue({
        el:'#example',
        data:obj,
        methods:{
            // reversedMessage:function(){
            //     // console.log(this)
            //     return this.title = '方法修改'
            // }
        },
        /**
         * 可以将同一个函数定义为同一个方法而不是一个计算属性，两种方式的最终结果确实相同，但不同的是计算属性是基于他们的响应式
         * 依赖进行缓存的。只有相关响应式依赖发生改变时它们才会重新求值。这就意味着只要message还没有发生改变，多次访问reversedMessage
         * 计算属性会立即返回之前的计算结果，而不必再次执行函数。
        */
        computed:{
            reversedMessage:function(){
                // console.log(this)
                return this.title = '方法修改'
            }
            
        },//计算属性
        beforeCreate(){
            userId:""
            openId:''
        },
        created:function(){
            // console.log(this.title)
        },
        beforeMounted(){

        },
        mounted(){

        },
        beforeUpdated(){

        },
        updated(){

        },
        beforeDestroyed(){

        },
        destroyed(){

        }

    })
    vm.reversedMessage();
    // console.log(vm.$data)
    
</script>
</html>